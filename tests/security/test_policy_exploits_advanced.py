"""
Advanced Policy Exploitation Test Suite
=======================================

This test suite focuses on specific advanced attack scenarios targeting
the policy system with sophisticated exploitation techniques used by
skilled attackers to find and exploit vulnerabilities.

Author: Senior Python QA Security Engineer
Target: Cedrina Policy System - Advanced Exploitation Scenarios
"""

import asyncio
import base64
import hashlib
import hmac
import json
import time
import uuid
from datetime import datetime, timedelta
from typing import Dict, List, Any

import httpx
import pytest
from sqlalchemy import text
from sqlalchemy.ext.asyncio import AsyncSession

from tests.conftest import async_client, admin_token, regular_user_token


class AdvancedPolicyExploitationTests:
    """Advanced exploitation scenarios for policy system security testing."""

    # =================================================================
    # CATEGORY 1: ADVANCED AUTHENTICATION ATTACKS
    # =================================================================

    @pytest.mark.asyncio
    async def test_jwt_algorithm_confusion_attack(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test JWT algorithm confusion attacks (RS256 vs HS256)."""
        
        # Decode the original token to get payload
        token_parts = admin_token.split('.')
        header = json.loads(base64.urlsafe_b64decode(token_parts[0] + '=='))
        payload = json.loads(base64.urlsafe_b64decode(token_parts[1] + '=='))
        
        # Test algorithm confusion attacks
        malicious_tokens = []
        
        # 1. None algorithm attack
        none_header = {"alg": "none", "typ": "JWT"}
        none_token = base64.urlsafe_b64encode(json.dumps(none_header).encode()).decode().rstrip('=')
        none_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        malicious_tokens.append(f"{none_token}.{none_payload}.")
        
        # 2. Algorithm downgrade attack (RS256 -> HS256)
        if header.get('alg') == 'RS256':
            hs256_header = {**header, "alg": "HS256"}
            hs256_header_b64 = base64.urlsafe_b64encode(json.dumps(hs256_header).encode()).decode().rstrip('=')
            hs256_payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
            
            # Try to sign with common weak secrets
            weak_secrets = ["secret", "password", "key", "admin", "cedrina"]
            for secret in weak_secrets:
                message = f"{hs256_header_b64}.{hs256_payload_b64}"
                signature = hmac.new(secret.encode(), message.encode(), hashlib.sha256).digest()
                signature_b64 = base64.urlsafe_b64encode(signature).decode().rstrip('=')
                malicious_tokens.append(f"{message}.{signature_b64}")
        
        # 3. Key confusion attack (using public key as HMAC secret)
        # This would require access to the public key, so we'll simulate
        public_key_attack = f"{token_parts[0]}.{token_parts[1]}.forged_signature"
        malicious_tokens.append(public_key_attack)
        
        # Test all malicious tokens
        policy = {"subject": "jwt_attack_test", "object": "/test", "action": "GET"}
        
        for malicious_token in malicious_tokens:
            headers = {"Authorization": f"Bearer {malicious_token}"}
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=policy
            )
            
            # All should be rejected
            assert response.status_code == 401, f"JWT algorithm confusion attack succeeded: {malicious_token[:50]}..."

    @pytest.mark.asyncio
    async def test_jwt_timing_attack_protection(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test JWT timing attack protection."""
        
        # Generate tokens with different signature lengths to test timing attacks
        base_token = admin_token.rsplit('.', 1)[0]  # Remove signature
        
        timing_tokens = [
            f"{base_token}.short",
            f"{base_token}.medium_length_sig",
            f"{base_token}.very_long_signature_that_might_cause_timing_differences",
            f"{base_token}." + "A" * 100,
            f"{base_token}." + "B" * 200,
        ]
        
        policy = {"subject": "timing_test", "object": "/test", "action": "GET"}
        response_times = []
        
        for token in timing_tokens:
            headers = {"Authorization": f"Bearer {token}"}
            
            start_time = time.time()
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=policy
            )
            end_time = time.time()
            
            response_times.append(end_time - start_time)
            
            # Should reject invalid tokens
            assert response.status_code == 401, f"Invalid token accepted: {token[:50]}..."
        
        # Check if timing differences are minimal (constant time verification)
        max_time = max(response_times)
        min_time = min(response_times)
        timing_difference = max_time - min_time
        
        # Timing difference should be minimal (< 50ms indicates good constant-time implementation)
        assert timing_difference < 0.05, f"JWT timing attack vulnerability detected: {timing_difference:.3f}s difference"

    @pytest.mark.asyncio
    async def test_token_sidejacking_and_fixation(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test token sidejacking and session fixation attacks."""
        
        # Test 1: Token reuse from different IP addresses
        headers_different_ips = [
            {"Authorization": f"Bearer {admin_token}", "X-Forwarded-For": "192.168.1.100"},
            {"Authorization": f"Bearer {admin_token}", "X-Forwarded-For": "10.0.0.50"},
            {"Authorization": f"Bearer {admin_token}", "X-Forwarded-For": "172.16.0.20"},
            {"Authorization": f"Bearer {admin_token}", "X-Real-IP": "203.0.113.10"},
        ]
        
        policy = {"subject": "sidejack_test", "object": "/test", "action": "GET"}
        
        for headers in headers_different_ips:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=policy
            )
            
            # Should either accept (if no IP binding) or reject (if IP binding enabled)
            assert response.status_code in [201, 401, 403], f"Unexpected response for IP change: {headers}"
        
        # Test 2: Token reuse with different User-Agent
        headers_different_agents = [
            {"Authorization": f"Bearer {admin_token}", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"},
            {"Authorization": f"Bearer {admin_token}", "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7)"},
            {"Authorization": f"Bearer {admin_token}", "User-Agent": "curl/7.68.0"},
        ]
        
        for headers in headers_different_agents:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=policy
            )
            
            # Should handle User-Agent changes gracefully
            assert response.status_code in [201, 401, 403], f"Unexpected response for User-Agent change: {headers}"

    # =================================================================
    # CATEGORY 2: ADVANCED POLICY INJECTION ATTACKS
    # =================================================================

    @pytest.mark.asyncio
    async def test_casbin_rule_injection_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test Casbin-specific rule injection attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Casbin rule injection payloads
        casbin_injection_payloads = [
            # Direct rule injection
            {"subject": "user\np,attacker,/admin/*,*", "object": "/test", "action": "GET"},
            {"subject": "user\ng,attacker,admin", "object": "/test", "action": "GET"},
            
            # Policy type manipulation
            {"subject": "user", "object": "/test\np,attacker,/admin/*,*", "action": "GET"},
            {"subject": "user", "object": "/test", "action": "GET\ng,attacker,admin"},
            
            # Role hierarchy injection
            {"subject": "user\ng,user,admin\ng,admin,superuser", "object": "/test", "action": "GET"},
            
            # Complex nested injection
            {"subject": "user\np,attacker,/admin/*,*\ng,attacker,admin", "object": "/test", "action": "GET"},
            
            # CSV injection (if rules are stored in CSV format)
            {"subject": "user\",\"/admin/*\",\"*\"\n\"attacker", "object": "/test", "action": "GET"},
        ]
        
        for payload in casbin_injection_payloads:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=payload
            )
            
            # Should reject all Casbin injection attempts
            assert response.status_code == 422, f"Casbin rule injection not prevented: {payload}"
            
            # Verify no malicious rules were added
            policies_response = await async_client.get("/api/v1/admin/policies", headers=headers)
            assert policies_response.status_code == 200
            policies = policies_response.json()["policies"]
            
            # Check that no policy contains injection attempts
            for policy in policies:
                assert "attacker" not in policy["subject"], "Casbin rule injection succeeded"
                assert "superuser" not in policy["subject"], "Casbin rule injection succeeded"

    @pytest.mark.asyncio
    async def test_unicode_normalization_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test Unicode normalization attacks on policy fields."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Unicode normalization attack payloads
        unicode_attacks = [
            # Homograph attacks
            {"subject": "аdmin", "object": "/test", "action": "GET"},  # Cyrillic 'а' instead of 'a'
            {"subject": "adṁin", "object": "/test", "action": "GET"},  # Dotted 'm'
            {"subject": "admin‌", "object": "/test", "action": "GET"},  # Zero-width non-joiner
            
            # Normalization bypass
            {"subject": "admin\u0041\u0300", "object": "/test", "action": "GET"},  # À composed differently
            {"subject": "admin\u00C0", "object": "/test", "action": "GET"},  # À precomposed
            
            # Bidirectional text attacks
            {"subject": "admin\u202E", "object": "/test", "action": "GET"},  # Right-to-left override
            {"subject": "admin\u200F", "object": "/test", "action": "GET"},  # Right-to-left mark
            
            # Control character attacks
            {"subject": "admin\u0000", "object": "/test", "action": "GET"},  # Null character
            {"subject": "admin\u0008", "object": "/test", "action": "GET"},  # Backspace
            {"subject": "admin\u000C", "object": "/test", "action": "GET"},  # Form feed
        ]
        
        for attack in unicode_attacks:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=attack
            )
            
            # Should handle Unicode attacks appropriately
            assert response.status_code in [201, 422], f"Unicode attack caused unexpected response: {attack}"
            
            # If accepted, verify proper storage
            if response.status_code == 201:
                policies_response = await async_client.get("/api/v1/admin/policies", headers=headers)
                assert policies_response.status_code == 200
                policies = policies_response.json()["policies"]
                
                # Should store the exact normalized form
                found_policy = False
                for policy in policies:
                    if policy["object"] == "/test":
                        found_policy = True
                        # Verify no dangerous characters remain
                        assert '\u0000' not in policy["subject"], "Null character not filtered"
                        assert '\u202E' not in policy["subject"], "BiDi override not filtered"
                        break
                
                assert found_policy, "Policy not found after creation"

    # =================================================================
    # CATEGORY 3: ADVANCED CONCURRENCY ATTACKS
    # =================================================================

    @pytest.mark.asyncio
    async def test_database_deadlock_exploitation(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test database deadlock exploitation attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Create policies that might cause deadlocks when modified concurrently
        base_policies = [
            {"subject": f"deadlock_user_{i}", "object": "/deadlock_test", "action": "GET"}
            for i in range(20)
        ]
        
        # Create base policies
        for policy in base_policies:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=policy
            )
            assert response.status_code == 201, f"Failed to create base policy: {policy}"
        
        # Concurrent operations that might cause deadlocks
        deadlock_tasks = []
        
        # Concurrent policy additions and removals
        for i in range(10):
            # Add task
            add_task = async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json={"subject": f"deadlock_new_{i}", "object": "/deadlock_test", "action": "POST"}
            )
            deadlock_tasks.append(add_task)
            
            # Remove task
            remove_task = async_client.post(
                "/api/v1/admin/policies/remove",
                headers=headers,
                json={"subject": f"deadlock_user_{i}", "object": "/deadlock_test", "action": "GET"}
            )
            deadlock_tasks.append(remove_task)
        
        # Execute all operations concurrently
        start_time = time.time()
        responses = await asyncio.gather(*deadlock_tasks, return_exceptions=True)
        end_time = time.time()
        
        # Analyze results
        successful_ops = sum(1 for r in responses if hasattr(r, 'status_code') and r.status_code in [200, 201])
        failed_ops = sum(1 for r in responses if hasattr(r, 'status_code') and r.status_code >= 400)
        exceptions = sum(1 for r in responses if isinstance(r, Exception))
        
        # System should handle concurrent operations without deadlocks
        assert end_time - start_time < 30, f"Operations took too long, possible deadlock: {end_time - start_time:.2f}s"
        assert exceptions == 0, f"Exceptions occurred, possible deadlock: {exceptions}"
        assert successful_ops + failed_ops == len(deadlock_tasks), "Some operations lost during concurrent execution"

    @pytest.mark.asyncio
    async def test_transaction_isolation_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test transaction isolation vulnerabilities."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Test dirty read attacks
        # Create a policy that will be modified concurrently
        base_policy = {"subject": "isolation_test", "object": "/isolation", "action": "GET"}
        response = await async_client.post(
            "/api/v1/admin/policies/add",
            headers=headers,
            json=base_policy
        )
        assert response.status_code == 201, "Failed to create base policy"
        
        # Concurrent modification and read operations
        isolation_tasks = []
        
        # Multiple concurrent modifications
        for i in range(5):
            # Add similar policies
            add_task = async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json={"subject": "isolation_test", "object": f"/isolation_{i}", "action": "GET"}
            )
            isolation_tasks.append(add_task)
            
            # Read policies
            read_task = async_client.get("/api/v1/admin/policies", headers=headers)
            isolation_tasks.append(read_task)
        
        # Execute all operations concurrently
        responses = await asyncio.gather(*isolation_tasks, return_exceptions=True)
        
        # Verify transaction isolation
        read_responses = [r for r in responses if hasattr(r, 'status_code') and r.status_code == 200]
        
        # All read responses should be consistent
        for read_response in read_responses:
            if hasattr(read_response, 'json'):
                try:
                    policies = read_response.json()["policies"]
                    # Verify data consistency
                    isolation_policies = [p for p in policies if p["subject"] == "isolation_test"]
                    assert len(isolation_policies) >= 1, "Transaction isolation violation detected"
                except:
                    # JSON parsing errors are acceptable in some cases
                    pass

    # =================================================================
    # CATEGORY 4: ADVANCED BYPASS TECHNIQUES
    # =================================================================

    @pytest.mark.asyncio
    async def test_http_parameter_pollution_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test HTTP parameter pollution attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Test parameter pollution in various ways
        pollution_attacks = [
            # JSON parameter pollution
            '{"subject": "user", "subject": "admin", "object": "/test", "action": "GET"}',
            '{"subject": "user", "object": "/test", "object": "/admin", "action": "GET"}',
            '{"subject": "user", "object": "/test", "action": "GET", "action": "*"}',
            
            # Nested parameter pollution
            '{"subject": "user", "object": "/test", "action": "GET", "extra": {"subject": "admin"}}',
            
            # Array parameter pollution
            '{"subject": ["user", "admin"], "object": "/test", "action": "GET"}',
            '{"subject": "user", "object": ["/test", "/admin"], "action": "GET"}',
        ]
        
        for attack_payload in pollution_attacks:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                content=attack_payload,
                headers={**headers, "Content-Type": "application/json"}
            )
            
            # Should handle parameter pollution gracefully
            assert response.status_code in [400, 422], f"Parameter pollution not handled: {attack_payload[:50]}..."

    @pytest.mark.asyncio
    async def test_content_type_confusion_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test content type confusion attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        policy_data = {"subject": "content_test", "object": "/test", "action": "GET"}
        
        # Test different content types for the same data
        content_type_attacks = [
            # XML instead of JSON
            ("application/xml", '<?xml version="1.0"?><policy><subject>admin</subject><object>/admin</object><action>*</action></policy>'),
            
            # Form data instead of JSON
            ("application/x-www-form-urlencoded", "subject=admin&object=/admin&action=*"),
            
            # Multipart form data
            ("multipart/form-data", "subject=admin&object=/admin&action=*"),
            
            # Plain text
            ("text/plain", json.dumps(policy_data)),
            
            # Incorrect charset
            ("application/json; charset=utf-16", json.dumps(policy_data)),
            
            # YAML (if supported)
            ("application/x-yaml", "subject: admin\nobject: /admin\naction: '*'"),
        ]
        
        for content_type, payload in content_type_attacks:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers={**headers, "Content-Type": content_type},
                content=payload
            )
            
            # Should reject non-JSON content types
            assert response.status_code in [400, 415, 422], f"Content type confusion not handled: {content_type}"

    @pytest.mark.asyncio
    async def test_http_method_override_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test HTTP method override attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        policy_data = {"subject": "method_test", "object": "/test", "action": "GET"}
        
        # Test method override headers
        method_override_attacks = [
            {"X-HTTP-Method-Override": "DELETE"},
            {"X-HTTP-Method": "PUT"},
            {"X-Method-Override": "PATCH"},
            {"X-HTTP-Method-Override": "ADMIN"},  # Invalid method
        ]
        
        for override_header in method_override_attacks:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers={**headers, **override_header},
                json=policy_data
            )
            
            # Should ignore method override headers or handle appropriately
            assert response.status_code in [201, 400, 405, 422], f"Method override attack succeeded: {override_header}"

    # =================================================================
    # CATEGORY 5: ADVANCED INFORMATION DISCLOSURE ATTACKS
    # =================================================================

    @pytest.mark.asyncio
    async def test_error_message_information_disclosure(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test for information disclosure in error messages."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Create intentionally problematic requests to trigger errors
        error_inducing_payloads = [
            # Extremely long strings
            {"subject": "A" * 100000, "object": "/test", "action": "GET"},
            
            # Special characters that might cause encoding issues
            {"subject": "test\x00\x01\x02", "object": "/test", "action": "GET"},
            
            # Nested objects
            {"subject": {"nested": "value"}, "object": "/test", "action": "GET"},
            
            # Missing required fields
            {"object": "/test", "action": "GET"},
            {"subject": "test", "action": "GET"},
            {"subject": "test", "object": "/test"},
        ]
        
        for payload in error_inducing_payloads:
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=payload
            )
            
            # Should return appropriate error codes
            assert response.status_code in [400, 422], f"Unexpected response for error payload: {payload}"
            
            # Check error message for information disclosure
            error_text = response.text.lower()
            
            # Should not contain sensitive information
            sensitive_keywords = [
                "password", "secret", "key", "token", "database", "sql", "connection",
                "server", "host", "port", "username", "credential", "admin", "root",
                "config", "env", "environment", "path", "file", "directory", "traceback",
                "exception", "stack", "internal", "debug", "dev", "development"
            ]
            
            for keyword in sensitive_keywords:
                assert keyword not in error_text, f"Sensitive information disclosed in error: {keyword}"

    @pytest.mark.asyncio
    async def test_timing_based_information_disclosure(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test for timing-based information disclosure."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # First, create a known policy
        known_policy = {"subject": "timing_known", "object": "/test", "action": "GET"}
        response = await async_client.post(
            "/api/v1/admin/policies/add",
            headers=headers,
            json=known_policy
        )
        assert response.status_code == 201, "Failed to create known policy"
        
        # Test timing differences between existing and non-existing policies
        test_policies = [
            {"subject": "timing_known", "object": "/test", "action": "GET"},  # Existing
            {"subject": "timing_unknown", "object": "/test", "action": "GET"},  # Non-existing
        ]
        
        timing_results = []
        
        for policy in test_policies:
            times = []
            for _ in range(10):  # Multiple measurements for accuracy
                start_time = time.time()
                response = await async_client.post(
                    "/api/v1/admin/policies/add",
                    headers=headers,
                    json=policy
                )
                end_time = time.time()
                times.append(end_time - start_time)
            
            avg_time = sum(times) / len(times)
            timing_results.append(avg_time)
        
        # Check for significant timing differences
        if len(timing_results) == 2:
            timing_difference = abs(timing_results[0] - timing_results[1])
            # Timing difference should be minimal to prevent information disclosure
            assert timing_difference < 0.1, f"Timing-based information disclosure detected: {timing_difference:.3f}s"

    # =================================================================
    # CATEGORY 6: ADVANCED DENIAL OF SERVICE ATTACKS
    # =================================================================

    @pytest.mark.asyncio
    async def test_regex_dos_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test Regular Expression Denial of Service (ReDoS) attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # ReDoS payloads that might cause exponential backtracking
        redos_payloads = [
            # Catastrophic backtracking patterns
            {"subject": "a" * 1000 + "X", "object": "/test", "action": "GET"},
            {"subject": "(" + "a" * 100 + ")*" + "b", "object": "/test", "action": "GET"},
            
            # Nested quantifiers
            {"subject": "a" * 50 + "b" * 50 + "c", "object": "/test", "action": "GET"},
            
            # Alternation with backtracking
            {"subject": "a|a" * 100, "object": "/test", "action": "GET"},
        ]
        
        for payload in redos_payloads:
            start_time = time.time()
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=payload,
                timeout=5.0  # Short timeout to detect ReDoS
            )
            end_time = time.time()
            
            # Should handle quickly without exponential backtracking
            assert end_time - start_time < 2.0, f"Possible ReDoS vulnerability: {end_time - start_time:.2f}s"
            assert response.status_code in [201, 422], f"ReDoS payload caused error: {payload}"

    @pytest.mark.asyncio
    async def test_compression_bomb_attacks(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Test compression bomb attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Create highly compressible content (compression bombs)
        compression_payloads = [
            # Repetitive strings
            {"subject": "A" * 10000, "object": "/test", "action": "GET"},
            {"subject": "0" * 50000, "object": "/test", "action": "GET"},
            
            # Nested structures
            {"subject": "test", "object": "/test", "action": "GET", "extra": "B" * 20000},
        ]
        
        for payload in compression_payloads:
            # Add compression headers
            compression_headers = {
                **headers,
                "Content-Encoding": "gzip",
                "Accept-Encoding": "gzip, deflate"
            }
            
            response = await async_client.post(
                "/api/v1/admin/policies/add",
                headers=compression_headers,
                json=payload
            )
            
            # Should handle large payloads appropriately
            assert response.status_code in [201, 413, 422], f"Compression bomb not handled: {len(str(payload))}"

    @pytest.mark.asyncio
    async def test_slowloris_simulation(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str
    ):
        """Simulate Slowloris-style slow request attacks."""
        headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Create slow requests that tie up connections
        slow_tasks = []
        
        for i in range(50):  # Multiple slow connections
            # Create a task that will be slow
            policy = {"subject": f"slow_test_{i}", "object": "/test", "action": "GET"}
            
            # Use a very long timeout to simulate slow client
            task = async_client.post(
                "/api/v1/admin/policies/add",
                headers=headers,
                json=policy,
                timeout=60.0  # Very long timeout
            )
            slow_tasks.append(task)
        
        # Execute some tasks concurrently (simulating slowloris)
        start_time = time.time()
        try:
            # Only wait for first 10 to complete, cancel the rest
            responses = await asyncio.wait_for(
                asyncio.gather(*slow_tasks[:10], return_exceptions=True),
                timeout=30.0
            )
            
            # Cancel remaining tasks
            for task in slow_tasks[10:]:
                task.cancel()
            
            end_time = time.time()
            
            # System should handle slow requests without hanging
            assert end_time - start_time < 35.0, f"System hung during slow request attack: {end_time - start_time:.2f}s"
            
            # Check that some requests succeeded
            successful_responses = sum(1 for r in responses if hasattr(r, 'status_code') and r.status_code in [200, 201])
            assert successful_responses > 0, "System completely failed under slow request attack"
            
        except asyncio.TimeoutError:
            # If timeout occurs, cancel all tasks
            for task in slow_tasks:
                task.cancel()
            
            # Timeout is acceptable behavior for DoS protection
            assert True, "System properly timed out slow requests"

    # =================================================================
    # COMPREHENSIVE EXPLOITATION REPORT
    # =================================================================

    @pytest.mark.asyncio
    async def test_comprehensive_exploitation_assessment(
        self, 
        async_client: httpx.AsyncClient,
        admin_token: str,
        regular_user_token: str
    ):
        """Comprehensive exploitation assessment combining all attack vectors."""
        
        exploitation_report = {
            "jwt_attacks": {"attempted": 0, "successful": 0, "blocked": 0},
            "injection_attacks": {"attempted": 0, "successful": 0, "blocked": 0},
            "concurrency_attacks": {"attempted": 0, "successful": 0, "blocked": 0},
            "bypass_attacks": {"attempted": 0, "successful": 0, "blocked": 0},
            "information_disclosure": {"attempted": 0, "successful": 0, "blocked": 0},
            "dos_attacks": {"attempted": 0, "successful": 0, "blocked": 0},
        }
        
        # Multi-stage exploitation attempt
        admin_headers = {"Authorization": f"Bearer {admin_token}"}
        
        # Stage 1: Advanced JWT exploitation
        exploitation_report["jwt_attacks"]["attempted"] += 1
        malicious_jwt = "eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJzdWIiOiJhZG1pbiIsImV4cCI6OTk5OTk5OTk5OX0."
        jwt_headers = {"Authorization": f"Bearer {malicious_jwt}"}
        
        response = await async_client.post(
            "/api/v1/admin/policies/add",
            headers=jwt_headers,
            json={"subject": "jwt_exploit", "object": "/admin", "action": "*"}
        )
        
        if response.status_code == 401:
            exploitation_report["jwt_attacks"]["blocked"] += 1
        else:
            exploitation_report["jwt_attacks"]["successful"] += 1
        
        # Stage 2: Complex injection attack
        exploitation_report["injection_attacks"]["attempted"] += 1
        injection_payload = {
            "subject": "user'; DROP TABLE casbin_rule; INSERT INTO casbin_rule VALUES ('p', 'attacker', '/admin/*', '*'); --",
            "object": "/test",
            "action": "GET"
        }
        
        response = await async_client.post(
            "/api/v1/admin/policies/add",
            headers=admin_headers,
            json=injection_payload
        )
        
        if response.status_code == 422:
            exploitation_report["injection_attacks"]["blocked"] += 1
        else:
            exploitation_report["injection_attacks"]["successful"] += 1
        
        # Stage 3: Concurrency exploitation
        exploitation_report["concurrency_attacks"]["attempted"] += 1
        
        # Create conflicting concurrent operations
        concurrent_tasks = []
        for i in range(10):
            task = async_client.post(
                "/api/v1/admin/policies/add",
                headers=admin_headers,
                json={"subject": "concurrent_exploit", "object": f"/test_{i}", "action": "GET"}
            )
            concurrent_tasks.append(task)
        
        responses = await asyncio.gather(*concurrent_tasks, return_exceptions=True)
        
        # Check for concurrency vulnerabilities
        successful_concurrent = sum(1 for r in responses if hasattr(r, 'status_code') and r.status_code == 201)
        if successful_concurrent == len(concurrent_tasks):
            exploitation_report["concurrency_attacks"]["blocked"] += 1
        else:
            exploitation_report["concurrency_attacks"]["successful"] += 1
        
        # Stage 4: Bypass technique
        exploitation_report["bypass_attacks"]["attempted"] += 1
        
        # HTTP parameter pollution
        polluted_payload = '{"subject": "user", "subject": "admin", "object": "/admin", "action": "*"}'
        response = await async_client.post(
            "/api/v1/admin/policies/add",
            headers=admin_headers,
            content=polluted_payload,
            headers={**admin_headers, "Content-Type": "application/json"}
        )
        
        if response.status_code in [400, 422]:
            exploitation_report["bypass_attacks"]["blocked"] += 1
        else:
            exploitation_report["bypass_attacks"]["successful"] += 1
        
        # Stage 5: Information disclosure attempt
        exploitation_report["information_disclosure"]["attempted"] += 1
        
        # Trigger error to check for information leakage
        response = await async_client.post(
            "/api/v1/admin/policies/add",
            headers=admin_headers,
            json={"subject": "A" * 100000, "object": "/test", "action": "GET"}
        )
        
        if response.status_code == 422:
            error_text = response.text.lower()
            if any(keyword in error_text for keyword in ["database", "sql", "server", "internal"]):
                exploitation_report["information_disclosure"]["successful"] += 1
            else:
                exploitation_report["information_disclosure"]["blocked"] += 1
        
        # Stage 6: DoS attempt
        exploitation_report["dos_attacks"]["attempted"] += 1
        
        # Resource exhaustion attempt
        dos_tasks = []
        for i in range(100):
            task = async_client.post(
                "/api/v1/admin/policies/add",
                headers=admin_headers,
                json={"subject": f"dos_test_{i}", "object": "/test", "action": "GET"}
            )
            dos_tasks.append(task)
        
        start_time = time.time()
        dos_responses = await asyncio.gather(*dos_tasks, return_exceptions=True)
        end_time = time.time()
        
        # Check if DoS was successful
        if end_time - start_time > 60 or len([r for r in dos_responses if isinstance(r, Exception)]) > 50:
            exploitation_report["dos_attacks"]["successful"] += 1
        else:
            exploitation_report["dos_attacks"]["blocked"] += 1
        
        # Generate comprehensive exploitation report
        print("\n" + "="*80)
        print("COMPREHENSIVE EXPLOITATION ASSESSMENT REPORT")
        print("="*80)
        print(f"Assessment Date: {datetime.now().isoformat()}")
        print()
        
        total_attempted = sum(category["attempted"] for category in exploitation_report.values())
        total_successful = sum(category["successful"] for category in exploitation_report.values())
        total_blocked = sum(category["blocked"] for category in exploitation_report.values())
        
        print(f"Total Exploitation Attempts: {total_attempted}")
        print(f"Total Successful Exploits: {total_successful}")
        print(f"Total Blocked Exploits: {total_blocked}")
        print(f"Security Defense Rate: {(total_blocked / total_attempted * 100):.1f}%")
        print()
        
        for category, results in exploitation_report.items():
            if results["attempted"] > 0:
                defense_rate = (results["blocked"] / results["attempted"] * 100)
                print(f"{category.replace('_', ' ').title()}: {results['blocked']}/{results['attempted']} blocked ({defense_rate:.1f}%)")
        
        print()
        print("EXPLOITATION RISK ASSESSMENT:")
        if total_successful == 0:
            print("✅ EXCELLENT: No successful exploits detected")
        elif total_successful <= 2:
            print("⚠️  GOOD: Minimal exploits successful, review and patch")
        elif total_successful <= 5:
            print("🔥 MODERATE: Some exploits successful, immediate attention required")
        else:
            print("💥 CRITICAL: Multiple exploits successful, system vulnerable")
        
        print("="*80)
        
        # Assert security posture
        assert total_successful <= 1, f"Multiple security exploits successful: {total_successful}"
        assert total_blocked >= total_attempted * 0.9, f"Security defense rate below 90%: {total_blocked}/{total_attempted}"


# Test execution marker
if __name__ == "__main__":
    print("Advanced Policy Exploitation Test Suite")
    print("Run with: pytest tests/security/test_policy_exploits_advanced.py -v")
    print("For comprehensive report: pytest tests/security/test_policy_exploits_advanced.py::AdvancedPolicyExploitationTests::test_comprehensive_exploitation_assessment -v -s")