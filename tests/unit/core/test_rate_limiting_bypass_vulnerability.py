"""Tests for rate limiting bypass vulnerability and its fix.

This test module demonstrates the critical security vulnerability where rate limiting
can be bypassed by spoofing headers, and then tests the secure implementation.
"""

import pytest
from unittest.mock import Mock, patch
from starlette.requests import Request
from starlette.datastructures import Headers, URL

from src.core.ratelimiter import _should_bypass_rate_limit, _get_bypass_reason
from src.config.rate_limiting import RateLimitingConfig


class TestRateLimitingBypassVulnerability:
    """Tests demonstrating the rate limiting bypass vulnerability."""

    def create_mock_request(
        self, 
        client_ip: str = "192.168.1.100", 
        path: str = "/api/v1/auth/login",
        headers: dict = None,
        user=None
    ) -> Request:
        """Create a mock request for testing."""
        mock_client = Mock()
        mock_client.host = client_ip
        
        mock_url = Mock()
        mock_url.path = path
        
        request_headers = Headers(headers or {})
        
        request = Mock(spec=Request)
        request.client = mock_client
        request.url = mock_url
        request.headers = request_headers
        
        # Simulate user context (e.g., set by authentication middleware)
        request.state = Mock()
        request.state.user = user  # This will be None for unauthenticated requests
        
        return request

    def test_vulnerability_header_spoofing_bypass(self):
        """Test that rate limiting CANNOT be bypassed by spoofing headers (SECURITY FIXED)."""
        # Arrange - Create request with spoofed headers
        spoofed_headers = {
            "X-User-ID": "admin",
            "X-User-Tier": "premium"
        }
        request = self.create_mock_request(headers=spoofed_headers, user=None)  # No authenticated user

        # Configure rate limiting to bypass for admin user and premium tier
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = False
            mock_config.get_bypass_reason.return_value = None

            # Act - Check if rate limiting is bypassed
            should_bypass = _should_bypass_rate_limit(request)
            bypass_reason = _get_bypass_reason(request)

            # Assert - SECURITY FIXED: Rate limiting is NOT bypassed due to spoofed headers
            assert should_bypass is False, "Rate limiting should NOT be bypassed due to spoofed headers"
            assert bypass_reason is None

            # Verify the secure implementation ignores spoofed headers
            mock_config.should_bypass_rate_limit.assert_called_once_with(
                client_ip="192.168.1.100",
                user_id=None,  # SECURITY FIXED: Spoofed header ignored
                endpoint="/api/v1/auth/login",
                user_tier=None  # SECURITY FIXED: Spoofed header ignored
            )

    @pytest.mark.parametrize("headers", [
        {"X-User-ID": "admin", "X-User-Tier": "enterprise"},
        {"X-User-ID": "test_user", "X-User-Tier": "premium"},
        {"X-User-ID": "any_user", "X-User-Tier": "api"},
        {"X-User-ID": "malicious_user", "X-User-Tier": "unlimited"},
    ])
    def test_vulnerability_multiple_spoofed_headers(self, headers):
        """Test that different combinations of spoofed headers CANNOT bypass rate limiting (SECURITY FIXED)."""
        request = self.create_mock_request(headers=headers, user=None)  # No authenticated user

        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = False

            # Act
            should_bypass = _should_bypass_rate_limit(request)

            # Assert - SECURITY FIXED: Spoofed headers cannot bypass rate limiting
            assert should_bypass is False, f"Rate limiting should NOT be bypassed with headers: {headers}"

            # Verify the secure implementation ignores all spoofed headers
            mock_config.should_bypass_rate_limit.assert_called_once_with(
                client_ip="192.168.1.100",
                user_id=None,  # SECURITY FIXED: All spoofed headers ignored
                endpoint="/api/v1/auth/login",
                user_tier=None  # SECURITY FIXED: All spoofed headers ignored
            )

    def test_vulnerability_empty_headers_still_bypass(self):
        """Test that empty or missing headers work correctly with secure implementation."""
        # Test with empty headers
        request = self.create_mock_request(headers={}, user=None)  # No authenticated user

        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = False

            # Act
            should_bypass = _should_bypass_rate_limit(request)

            # Assert - Secure implementation handles empty headers correctly
            assert should_bypass is False
            mock_config.should_bypass_rate_limit.assert_called_once_with(
                client_ip="192.168.1.100",
                user_id=None,  # SECURITY FIXED: No user context
                endpoint="/api/v1/auth/login",
                user_tier=None  # SECURITY FIXED: No user context
            )

    @pytest.mark.parametrize("headers", [
        {"x-user-id": "admin", "x-user-tier": "premium"},
        {"X-USER-ID": "admin", "X-USER-TIER": "premium"},
        {"x-User-Id": "admin", "x-User-Tier": "premium"},
    ])
    def test_vulnerability_case_insensitive_headers(self, headers):
        """Test that header case variations can still bypass rate limiting."""
        request = self.create_mock_request(headers=headers)
        
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = True
            
            # Act
            should_bypass = _should_bypass_rate_limit(request)
            
            # Assert - VULNERABILITY: Case variations still bypass rate limiting
            assert should_bypass is True, f"Rate limiting should be bypassed with case variation: {headers}"


class TestRateLimitingBypassSecurityFix:
    """Tests for the secure rate limiting bypass implementation."""

    def create_mock_request(self, client_ip="192.168.1.100", path="/api/v1/auth/login", headers=None, user=None):
        from unittest.mock import Mock
        from starlette.datastructures import Headers
        mock_client = Mock()
        mock_client.host = client_ip
        mock_url = Mock()
        mock_url.path = path
        request_headers = Headers(headers or {})
        request = Mock()
        request.client = mock_client
        request.url = mock_url
        request.headers = request_headers
        # Simulate user context (e.g., set by authentication middleware)
        request.state = Mock()
        request.state.user = user  # This will be None for unauthenticated requests
        return request

    def test_secure_bypass_requires_authenticated_user(self, caplog):
        """Bypass only works for authenticated users, not spoofed headers."""
        from src.core.ratelimiter import _should_bypass_rate_limit
        # Simulate an authenticated user (from session/JWT, not header)
        user = type("User", (), {"id": "admin", "is_superuser": True})()
        request = self.create_mock_request(user=user)
        # Patch config to allow bypass for this user
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = True
            # Act
            should_bypass = _should_bypass_rate_limit(request)
            # Assert
            assert should_bypass is True, "Authenticated user should be able to bypass if allowed by config"
            # No spoofed header usage
            assert "X-User-ID" not in str(request.headers)

    def test_secure_bypass_ignores_spoofed_headers(self, caplog):
        """Spoofed headers are ignored in the secure implementation."""
        from src.core.ratelimiter import _should_bypass_rate_limit
        spoofed_headers = {"X-User-ID": "admin", "X-User-Tier": "premium"}
        request = self.create_mock_request(headers=spoofed_headers, user=None)
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = False
            # Act
            should_bypass = _should_bypass_rate_limit(request)
            # Assert
            assert should_bypass is False, "Spoofed headers must not allow bypass"
            # Check for security log
            assert any("rate limit bypass attempt via headers" in m for m in caplog.messages)

    def test_secure_bypass_uses_jwt_token_validation(self):
        """Bypass uses JWT/session user, not headers."""
        from src.core.ratelimiter import _should_bypass_rate_limit
        # Simulate a user loaded from JWT/session
        user = type("User", (), {"id": "api_admin", "is_superuser": True})()
        request = self.create_mock_request(user=user)
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = True
            should_bypass = _should_bypass_rate_limit(request)
            assert should_bypass is True

    def test_secure_bypass_logs_security_events(self, caplog):
        """Security events are logged when bypass attempts are detected via headers."""
        from src.core.ratelimiter import _should_bypass_rate_limit
        spoofed_headers = {"X-User-ID": "admin", "X-User-Tier": "premium"}
        request = self.create_mock_request(headers=spoofed_headers, user=None)
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = False
            _should_bypass_rate_limit(request)
            assert any("rate limit bypass attempt via headers" in m for m in caplog.messages)


class TestRateLimitingConfigurationSecurity:
    """Tests for rate limiting configuration security."""

    def test_configuration_validation_rejects_insecure_settings(self):
        """Test that configuration validation maintains secure defaults."""
        # Test that the configuration system maintains secure defaults
        config = RateLimitingConfig()

        # These should be safe defaults - empty sets mean no bypass
        assert config.disable_for_users == set()
        assert config.disable_for_user_tiers == set()

        # Test that the configuration is secure by default
        # No bypass should be allowed for unauthenticated users
        assert not config.should_bypass_rate_limit(
            client_ip="192.168.1.100",
            user_id=None,  # No authenticated user
            endpoint="/api/v1/auth/login",
            user_tier=None
        )

    def test_configuration_audit_logging(self):
        """Test that configuration changes are audited."""
        # Test that configuration changes are logged for security auditing
        pass 

class TestRateLimitingSecurityVerification:
    """Comprehensive security verification tests for rate limiting bypass vulnerability."""

    def create_mock_request(self, client_ip="192.168.1.100", path="/api/v1/auth/login", headers=None, user=None):
        from unittest.mock import Mock
        from starlette.datastructures import Headers
        mock_client = Mock()
        mock_client.host = client_ip
        mock_url = Mock()
        mock_url.path = path
        request_headers = Headers(headers or {})
        request = Mock()
        request.client = mock_client
        request.url = mock_url
        request.headers = request_headers
        request.state = Mock()
        request.state.user = user
        return request

    def test_comprehensive_security_verification(self, caplog):
        """Comprehensive test to verify the rate limiting bypass vulnerability is completely fixed."""
        from src.core.ratelimiter import _should_bypass_rate_limit
        
        # Test Case 1: Spoofed admin headers (should be ignored)
        spoofed_admin_headers = {"X-User-ID": "admin", "X-User-Tier": "premium"}
        request1 = self.create_mock_request(headers=spoofed_admin_headers, user=None)
        
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = False
            should_bypass1 = _should_bypass_rate_limit(request1)
            
            # Verify spoofed headers are ignored
            assert should_bypass1 is False, "Spoofed admin headers should be ignored"
            mock_config.should_bypass_rate_limit.assert_called_with(
                client_ip="192.168.1.100",
                user_id=None,  # SECURITY FIXED: Spoofed header ignored
                endpoint="/api/v1/auth/login",
                user_tier=None  # SECURITY FIXED: Spoofed header ignored
            )
        
        # Test Case 2: Authenticated user (should work if allowed)
        authenticated_user = type("User", (), {"id": "real_admin", "tier": "premium"})()
        request2 = self.create_mock_request(user=authenticated_user)
        
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = True
            should_bypass2 = _should_bypass_rate_limit(request2)
            
            # Verify authenticated user can bypass if allowed
            assert should_bypass2 is True, "Authenticated user should be able to bypass if allowed"
            mock_config.should_bypass_rate_limit.assert_called_with(
                client_ip="192.168.1.100",
                user_id="real_admin",  # SECURITY FIXED: From trusted context
                endpoint="/api/v1/auth/login",
                user_tier="premium"  # SECURITY FIXED: From trusted context
            )
        
        # Test Case 3: Mixed scenario - authenticated user with spoofed headers
        authenticated_user_with_spoofed_headers = type("User", (), {"id": "real_user", "tier": "basic"})()
        request3 = self.create_mock_request(
            headers={"X-User-ID": "fake_admin", "X-User-Tier": "premium"},
            user=authenticated_user_with_spoofed_headers
        )
        
        with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
            mock_config.should_bypass_rate_limit.return_value = False
            should_bypass3 = _should_bypass_rate_limit(request3)
            
            # Verify trusted context is used, spoofed headers ignored
            assert should_bypass3 is False, "Should use trusted context, ignore spoofed headers"
            mock_config.should_bypass_rate_limit.assert_called_with(
                client_ip="192.168.1.100",
                user_id="real_user",  # SECURITY FIXED: From trusted context
                endpoint="/api/v1/auth/login",
                user_tier="basic"  # SECURITY FIXED: From trusted context
            )
        
        # Test Case 4: Verify security logging
        assert any("Potential rate limit bypass attempt via headers" in m for m in caplog.messages), \
            "Security events should be logged for spoofed header attempts"

    def test_vulnerability_completely_mitigated(self):
        """Test that the original vulnerability is completely mitigated."""
        from src.core.ratelimiter import _should_bypass_rate_limit
        
        # Original vulnerability: These headers could be spoofed
        vulnerable_headers = [
            {"X-User-ID": "admin", "X-User-Tier": "premium"},
            {"X-User-ID": "admin", "X-User-Tier": "enterprise"},
            {"X-User-ID": "any_user", "X-User-Tier": "unlimited"},
            {"X-User-ID": "malicious_user", "X-User-Tier": "api"},
        ]
        
        for headers in vulnerable_headers:
            request = self.create_mock_request(headers=headers, user=None)
            
            with patch('src.core.ratelimiter.rate_limiting_config') as mock_config:
                mock_config.should_bypass_rate_limit.return_value = False
                should_bypass = _should_bypass_rate_limit(request)
                
                # SECURITY FIXED: All spoofed headers should be ignored
                assert should_bypass is False, f"Vulnerability still exists for headers: {headers}"
                
                # Verify the secure implementation was called with None values
                mock_config.should_bypass_rate_limit.assert_called_with(
                    client_ip="192.168.1.100",
                    user_id=None,  # SECURITY FIXED: Spoofed header ignored
                    endpoint="/api/v1/auth/login",
                    user_tier=None  # SECURITY FIXED: Spoofed header ignored
                ) 